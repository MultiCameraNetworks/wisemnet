function [err_s]=CAWC_compute_accuracy(root_dir,results_dir,scenario,show_data)
% This script reads the data generated by the app 'wiseCameraCAWcamTrack'
% and computes the following statistics:
%   - Visualization of the error for each camera/run as an independent plot
%   - Average tracking error on the image-plane and ground-plane (camera tracker)
%   - Average tracking error on the image-plane and ground-plane (coalition tracker)
%
%   Input arguments:
%   - root_dir: location of the root directory with all experiments
%   - results_dir: location of the directory with the selected experiment
%   - scenario: tag to identify the scenario employed for the experiments
%               ='pets2009_S2_L1'
%               ='ICGLab6_chap'
%   - show_data: flag to show results
%               =0(none)
%               =1(shows results for video frames)
%               =2(shows overall results for sequence/run)
%
%   Example:
%           root_dir='/home/jcs/code/svn/multicamera/wise-mnet/dev/wise/simulations/wiseCameraCAWcamTrack/';
%           experiment='res_P_t09_7fps_25s_r50_o1';
%           err=CAWC_compute_accuracy(root_dir,experiment,'pets2009_S2_L1',0);
%
%   Author:      Juan Carlos SanMiguel (juancarlos.sanmiguel@uam.es)
%   Affiliation: University Autonoma of Madrid
%   URL:         http://www-vpu.ii.uam.es/~jcs
%   Date:        November 2015
addpath('./utils');

% check arguments
[root_dir,results_dir,scenario,show_data]=check_args(root_dir,results_dir,scenario,show_data);

%% LOAD SIMULATION DATA
fprintf('Loading simulation data...\n');
% try to load mat file
if exist(['./data/' results_dir '.mat'], 'file') == 2
    load(['./data/' results_dir '.mat']);
else
    [runs,coaData]=load_coa_data([root_dir results_dir]); %coalition tracking data
    [cams.track,ids,cids]=load_cams_data([root_dir results_dir]); %camera tracking data
    %[cams.usage,ids,cids]=load_cams_consumption([root_dir results_dir]);%camera consumption
    [Ncams,Nruns,Pclk,Sclk,optF,FPSreq,FPSrea,evalFr] = preprocess_data(cams);
    save(['./data/' results_dir '.mat']); 
end

%% LOAD CAMERA MODELS (ground-plane homographies)

%load scenario configuration(video files, ground-truth,...)
load_scenario_config;
config.mpp = config.mpp/4;%adjust ground-plane to metters conversion

%read camera model
for c=1:Ncams
    ind = find(cams.usage{c,1}.camID == config.selCams);
    fprintf('Loading %s\n',config.calFile{ind});
    cams.calib(c) = cameraModel([config.datasetDir config.calFile{ind}], config);
end

%read image plane annotation (feet location of the target in format <FR,XPOS,YPOS>)
ind = find(cams.track{1,1}.targetID == config.nTargetIDs);
tgGT_gp = dlmread([config.datasetDir config.gtFile{ind}], ',');

%read image plane annotation (bounding box in format <CAM,FR,XPOS,YPOS,WIDTH,HEIGHT>)
%tgtIni_ip = dlmread([config.datasetDir config.gtFileInit{1}], ',');

%% COMPUTE TRACKING ACCURACY FOR CAMERAS
fprintf('Computing tracking accuracy for cameras...\n');
% compute Image-plane (IP) and Ground-Plane (GP) error for cameras
% 'camTrack' structure contains all data for IP & GP error
err.camGP = cell(Ncams,numel(Pclk), numel(FPSreq));
err.camIP = cell(Ncams,numel(Pclk), numel(FPSreq));
for c=1:Ncams
     for r=1:Nruns     
        
        if show_data == 1 || show_data == 2
            %figure to display data
            figure('Name', sprintf('camera %d - run %d - %.2fGhz - %.2ffps',c,r,cams.usage{c,r}.PRO.clockfreq/1e9,cams.usage{c,r}.SEN.FPSrea), 'units','normalized','outerposition',[0 0 1 1]);
            
            if show_data == 1
                %video file of camera
                ind = find(cams.usage{c,1}.camID == config.selCams);
                v = VideoReader([config.datasetDir config.vidFile{ind}]);
            end
        end
        
        %resizing factor of input images
        xf = 1/cams.track{c,r}.sCols;
        yf = 1/cams.track{c,r}.sRows;
        
        camTrack(c,r).start = -1;
        camTrack(c,r).end = -1;
        frRead = 0;
        
        for n=1:numel(cams.track{c,r}.X0w); %total number of steps
            %cams.track{c,r}.frID(n)
            camTrack(c,r).xy_gp(n) = {[cams.track{c,r}.X0w(n) cams.track{c,r}.Y0w(n)]}; %ground-plane estimation
            camTrack(c,r).xy_ip(n) = {[cams.track{c,r}.X0i(n) cams.track{c,r}.Y0i(n)]}; %image-plane estimation
            
            ind=find(tgGT_gp(:,1) == cams.track{c,r}.frID(n)); %find current frame in ground-truth
            if (cams.track{c,r}.X0i(n) > 0 && numel(ind)>0) %if such frame exists
                
                %convert ground-truth to image-plane
                [tgGT_ip(1),tgGT_ip(2)]=cams.calib(c).worldToImage(tgGT_gp(ind,2),tgGT_gp(ind,3),0); %ground-plane gt to image-plane
                tgGT_ip = tgGT_ip./[xf yf]; %reescaling of image-plane estimation
                
                %tracking accuracy in image-plane (in pixels)
                camTrack(c,r).errIP(n)=norm(tgGT_ip - camTrack(c,r).xy_ip{n});
                
                %tracking accuracy in ground-plane (in meters)
                camTrack(c,r).errGP(n)=norm(config.mpp.*(tgGT_gp(ind,2:3) - camTrack(c,r).xy_gp{n}));
                
                %update start and end frames for the target data
                if (camTrack(c,r).start == -1)
                    camTrack(c,r).start = cams.track{c,r}.frID(n)+1;
                end
                camTrack(c,r).end = cams.track{c,r}.frID(n)+1;
                
            else %if such frame does not exist
                
                tgGT_ip = [NaN NaN];
                camTrack(c,r).errGP(n)=-1;
                camTrack(c,r).errIP(n)=-1;
            end
            
            %plot frame-by-frame results
            if show_data==1
                %read corresponding video frame to 'cams.track{c,r}.frID(n)'
                [frame, frRead]=read_nextFrame_and_resize(v, frRead, cams.track{c,r}.frID(n)+1, [480 752]);
                
                %plot tracking data (image, IP error & utility)
                subplot(4,1,1:2); imshow(frame); hold on;
                plot(tgGT_ip(1),tgGT_ip(2),'g+','MarkerSize',12,'LineWidth',3);
                plot(camTrack(c,r).xy_ip{n}(1),camTrack(c,r).xy_ip{n}(2),'b+','MarkerSize',12,'LineWidth',3);
                text('units','pixels','position',[10 10],'fontsize',16,'color','red', 'string',sprintf('Cam%d - run=%d Fr=%d u=%.2f',c,r,cams.track{c,r}.frID(n),cams.track{c,r}.u(n)));
                if cams.track{c,r}.Xi(n) > 0
                    rectangle('Position', [cams.track{c,r}.Xi(n) cams.track{c,r}.Yi(n) cams.track{c,r}.Wi(n) cams.track{c,r}.Hi(n)],'EdgeColor','blue');
                end
                hold off;
                %subplot 513; plot( cams.track{c,r}.frID(1:n),trk_cam(c,r).errIP); ylabel('IP error (pixels)');
                subplot 413; plot( cams.track{c,r}.frID(1:n),camTrack(c,r).errGP); ylabel('GP error (m)'); axis([1 cams.track{c,r}.frID(n)+1 min(min(camTrack(c,r).errGP),0) min(8,max(camTrack(c,r).errGP))+0.1])
                subplot 414; plot( cams.track{c,r}.frID(1:n),cams.track{c,r}.u(1:n)); ylabel('utility'); axis([1 cams.track{c,r}.frID(n)+1 min(0,min(cams.track{c,r}.u(1:n))) max(1,max(cams.track{c,r}.u(1:n)))])
            end
        end
        
        %plot sequence-by-sequence results
        if show_data==2
            subplot 411;
            scatter(camTrack(c,r).errIP,cams.track{c,r}.u(1:n)); xlabel('IP error'); ylabel('utility');
            ind1 = find(camTrack(c,r).errIP < 50);
            ind2 = find(camTrack(c,r).errIP > 50);
            a=cams.track{c,r}.u(1:n);
            title(sprintf('Camera %d - run %d - right (%.2f-%.2f) - wrong (%.2f-%.2f)',c,r,mean(a(ind1)),var(a(ind1)),mean(a(ind2)),var(a(ind2))));
            
            subplot 412; plot(cams.track{c,r}.frID(1:n),camTrack(c,r).errIP); ylabel('IP error'); %axis([cams.track{c,r}.frID(1) cams.track{c,r}.frID(end) 0 200]);
            subplot 413; plot(cams.track{c,r}.frID(1:n),camTrack(c,r).errGP); ylabel('GP error');
            subplot 414; plot(cams.track{c,r}.frID(1:n),cams.track{c,r}.u(1:n)); ylabel('utility');
            
        end
        
        if show_data==1 || show_data==2
            pause;
        end
        
        %find settings of current experiment
        ip = find(Pclk==cams.usage{c,r}.PRO.clockfreq); %index for the processing clock
        is = find(FPSreq==cams.usage{c,r}.SEN.FPSreq);  %index for the fps of sensing
        
        %frames where data is accumulated
        ind = find(ismember(cams.track{c,r}.frID, evalFr)); % Extract the elements of a at those indexes.
        if numel(ind) ~= numel(evalFr)
            %we uniformly sample the results if we do not find the frames to compare
            ind = find(camTrack(c,r).errGP > 0);
            if isempty(ind)
                ind=1:size(camTrack(c,r).errGP,2);
            else
                ind= ind(round(linspace(1,numel(ind),numel(evalFr))));
            end
        end
        
        %compute the mean error at sequence level
        err.camGP(c,ip,is) = {[err.camGP{c,ip,is} mean(camTrack(c,r).errGP(ind))]}; %average ground-plane error
        err.camIP(c,ip,is) = {[err.camIP{c,ip,is} mean(camTrack(c,r).errIP(ind))]}; %average image-plane error
        fprintf('\tc=%d r=%d fps=%.2f clk=%.2f -> Evaluation using %d frames\n',c,r,cams.usage{c,r}.SEN.FPSreq,cams.usage{c,r}.PRO.clockfreq/1e9,numel(ind));
    end
    close all;
end

%mean error across all runs
err.camGPm = zeros(Ncams,numel(Pclk),numel(FPSreq));
err.camGPv = zeros(Ncams,numel(Pclk),numel(FPSreq));
err.camIPm = zeros(Ncams,numel(Pclk),numel(FPSreq));
err.camIPv = zeros(Ncams,numel(Pclk),numel(FPSreq));
for c=1:Ncams
    [err.camGPm(c,:,:), err.camGPv(c,:,:)] = getMeanStdError(err.camGP(c,:,:));
    [err.camIPm(c,:,:), err.camIPv(c,:,:)] = getMeanStdError(err.camGP(c,:,:));
end

%% COMPUTE TRACKING ERROR FOR COALITION
fprintf('Computing tracking accuracy for coalition...\n');
err.coaGP = cell(numel(Pclk),numel(FPSreq));
err.coaIP = cell(numel(Pclk),numel(FPSreq));
for tt=1:numel(coaData)
    r = find (runs == coaData(tt).run); %run number
    
    %compute error in the ground-plane for each step
    for n=1:size(coaData(tt).data,2);
        coaTrack(tt).xy_gp(n) = {coaData(tt).data(n).x{1}(1:2)};
        
        ind=find(tgGT_gp(:,1) == coaData(tt).data(n).frameID+1);%find current frame in ground-truth
        if isempty(ind)
            coaTrack(tt).errGP(n)=NaN;
            coaTrack(tt).errIP(n)=NaN;
        else
            coaTrack(tt).errGP(n)=norm(config.mpp.*(tgGT_gp(ind,2:3) - coaTrack(tt).xy_gp{n}));
            coaTrack(tt).frID(n) = coaData(tt).data(n).frameID+1;
            
            %compute the error of the coalition on each camera view
            errCoaView = [];
            for c=1:Ncams
                [tgGT_ip(1),tgGT_ip(2)]=cams.calib(c).worldToImage(tgGT_gp(ind,2),tgGT_gp(ind,3),0);
                [coaIP(1),coaIP(2)]=cams.calib(c).worldToImage(coaTrack(tt).xy_gp{n}(1),coaTrack(tt).xy_gp{n}(2),0);
                sz=1;%sz = cams.track{c,r}.Wi(n)*cams.track{c,r}.Hi(n);
                errCoaView = [errCoaView norm(tgGT_ip-coaIP)/sz];
            end
            coaTrack(tt).errIP(n)=min(errCoaView);%report as result the minimum error on each view
        end
    end
    
    %find the real duration of the coalition
    coaData(tt).start = Inf;
    coaData(tt).end = -1;
    for c=1:Ncams
        coaData(tt).start = min(camTrack(c,r).start, coaData(tt).start);
        coaData(tt).end = min(camTrack(c,r).end, coaData(tt).end);
    end
    
    %find settings of current experiment
    ip = find(Pclk==cams.usage{1,r}.PRO.clockfreq); %index for the processing clock
    is = find(FPSreq==cams.usage{1,r}.SEN.FPSreq);  %index for the fps of sensing
    
    %compute the mean error at sequence level
    ind = find(ismember(coaTrack(tt).frID, evalFr)); % Extract the elements of a at those indexes.
    if numel(ind) ~= numel(evalFr)
        %we uniformly sample the results if we do not find the frames to compare
        ind = find(coaTrack(tt).errGP > 0);
        if isempty(ind)
            ind=1:size(coaTrack(tt).errGP,2);
        else
            ind= ind(round(linspace(1,numel(ind),numel(evalFr))));
        end
    end
    err.coaGP(ip,is) = {[err.coaGP{ip,is} mean(coaTrack(tt).errGP(ind))]};%ground-plane error
    err.coaIP(ip,is) = {[err.coaIP{ip,is} mean(coaTrack(tt).errIP(ind))]};%image-plane error
    fprintf('\tcoa=%d fps=%.2f clk=%.2f -> Evaluation using %d frames\n',tt,cams.usage{c,r}.SEN.FPSreq,cams.usage{c,r}.PRO.clockfreq/1e9,numel(ind));

end

%mean error across all runs
[err.coaGPm, err.coaGPv] = getMeanStdError(err.coaGP);
[err.coaIPm, err.coaIPv] = getMeanStdError(err.coaIP);

%% PLOT DATA
if show_data>0    
    %framerate & processing clock testing
    if(numel(FPSreq)>2 && numel(Pclk) > 2)
        % 3D plot for simultaneous testing of framerate and processing clock
        [N,M]=meshgrid(FPSreq,Pclk);
        hp=figure('Name','Tracking error ground-plane');
        for c=1:Ncams
            subplot(2,4,c); mesh(N,M,reshape(err.camGPm(c,:,:),[numel(Pclk) numel(FPSreq)])); plot_labels_axis(sprintf('Camera %d',c),'Mean tracking error GP (m)',Pclk,FPSreq);
        end
        subplot(2,4,8); mesh(N,M,err.coaGPm); plot_labels_axis('Coalition','Mean tracking error GP (m)',Pclk,FPSreq);
        
        hp=figure('Name','Tracking error image-plane');
        for c=1:Ncams
            subplot(2,4,c); mesh(N,M,reshape(err.camIPm(c,:,:),[numel(Pclk) numel(FPSreq)])); plot_labels_axis(sprintf('Camera %d',c),'Mean tracking error IP (pixels)',Pclk,FPSreq);
        end
        subplot(2,4,8); mesh(N,M,err.coaIPm); plot_labels_axis('Coalition','Mean tracking error GP (m)',Pclk,FPSreq);
    else
        %framerate testing
        if numel(FPSreq)>1             
            fgp1=figure('Name',sprintf('Tracking GP error for P=%.2fGHz',Pclk(1)/1e9),'Position', [100, 100, 700, 300]);
            tmp_m = err.camGPm; tmp_m(end+1,:,:) = err.coaGPm; tmp_m=reshape(tmp_m, [Ncams+1 max(size(err.coaIP))]);
            bar(tmp_m); legend(strread(num2str(FPSreq),'%s'),'Orientation','Horizontal','Location','Northoutside');
            set(gca,'XTick',1:Ncams+1, 'XTickLabel',[strread(num2str(1:Ncams),'%s');{'Coalition'}]); xlabel('camera');ylabel('GP tracking error (m)');
            box off;  %axis([0.5 numel(cids)+0.5 0 3.25])
        end
        %processing clock testing
        if numel(Pclk)>1
            fgp1=figure('Name',sprintf('Tracking GP error for fps=%.2f and different processing clocks',FPSreq(1)),'Position', [100, 100, 700, 300]);
            tmp_m = err.camGPm; tmp_m(end+1,:,:) = err.coaGPm; tmp_m=reshape(tmp_m, [Ncams+1 max(size(err.coaIP))]);
            bar(tmp_m); legend(strread(num2str(Pclk),'%s'),'Orientation','Horizontal','Location','Northoutside');
            set(gca,'XTick',1:Ncams+1, 'XTickLabel',[strread(num2str(1:Ncams),'%s');{'Coalition'}]); xlabel('camera');ylabel('GP tracking error (m)');
            box off;  %axis([0.5 numel(cids)+0.5 0 3.25])
            
        end
    end
end

%% SAVE RESULTS
fprintf('Data saved to %s',['./data/' results_dir '_TrackingErr.mat']);
err_s = struct('root_dir',root_dir,'results_dir',results_dir,'scenario',scenario,'cids',cids,...
                'Ncams',Ncams,'Nruns',Nruns,'fps',FPSreq,'Pclk',Pclk,'err',err);
save(['./data/' results_dir '_TrackingErr.mat'],'err_s');

function [root_dir,results_dir,scenario,show_data]=check_args(root_dir,results_dir,scenario,show_data)
% default values
if exist('root_dir') == 0 || exist('results_dir') == 0
    root_dir = '/home/jcs/code/svn/multicamera/wise-mnet/dev/wise/simulations/wiseCameraCAWcamTrack/';
    results_dir = 'res_P_t09_7fps_25s_r50_o1';
end

if exist('scenario') == 0
    scenario = 'pets2009';
    % scenario = 'ICGLab6_chap';
end

if exist('show_data') == 0
    show_data = 0;
end

function [frame, frRead]=read_nextFrame_and_resize(videofile, frRead, frReadNew, SizeNew)
frame = readFrame(videofile);
frRead = frRead + 1;
while (frRead ~= frReadNew)
    frame = readFrame(videofile);
    frRead = frRead + 1;
end
frame = imresize(frame, SizeNew);

function [meanData, stdData] = getMeanStdError(data)
if numel(size(data))==3 && size(data,1)==1
    data=reshape(data,[size(data,2) size(data,3)]);
end

for p=1:size(data,1)
    for s=1:size(data,2)
        meanData(p,s) = mean(data{p,s}(:));
        stdData(p,s) = std(data{p,s}(:));
    end
end