### ------------------------------------------------------------------------ ###
### wiseCameraCAWCTracker (PETS09_S2_L1): 
### 
### Description: multi-camera tracking for a single moving target in the 
###				'S2_L1' sequence (PETS09 dataset) with seven views
###
### Available simulations extending the configuration in [General]:
###		- [Config test]: basic functionality
### 	- [Config test_no_display]: basic functionality without displaying results
###		- [Config scalable]: tests for a range of operating frequencies for processing and sampling times for sensing
###		- [Config sensing]: tests for a range of sampling times for sensing
### 	- [Config processing]: tests for a range of operating frequencies for processing
###		- [Config fixed]: test for a fixed operating frequency for processing and sampling time for sensing
###		- [Config lifetime]: test for a number of code optimization factors
### See the configuration parameters at the bottom of this file.
###
###	References:	
###		- CAWC algorithm: 
###			SanMiguel and Cavallaro, "Cost-Aware Coalitions for Collaborative Tracking 
###			in Resource-Constrained Camera Networks", IEEE Sensors Journal, 2015 
###			http://ieeexplore.ieee.org/document/6945780/ 
###		
### Date: 2015-06-01 (updated 2017-06-01)
### Author: juancarlos.sanmiguel@uam.es (Universidad Autonoma de Madrid)
### 
### ------------------------------------------------------------------------ ###
[General]
include ../WiseCastalia.ini 	# ALWAYS include the WiseCastalia.ini file

# ==============================================
# Simulation setup
# ==============================================
#time where all cameras fail for target 9
sim-time-limit = 30s	# simulation duration
#sim-time-limit = ${ti=10s,20s,30s} #uncomment to run experiments 

record-eventlog = false

SN.field_x = 160		# meters
SN.field_y = 120		# meters

#Estimated ground-plane coordinates from http://www.milanton.de/data.html
#(xmin, xmax, ymin, ymax): (-14069.6, 4981.3, -14274.0, 1733.5)
SN.xmin = -80000		#minimum X-coordinate of the environment
SN.xmax = 80000			#maximum X-coordinate of the environment
SN.ymin = -80000		#minimum Y-coordinate of the environment
SN.ymax = 110000		#maximum Y-coordinate of the environment

SN.numNodes = 7			#number of available views/cameras
SN.deployment = "center"#default positions of cameras

SN.use_calibration = true			#flag to indicate if the scenario contains calibration data

#GUI to visualize an empty terrain (white/black zhenital view with FOVs and moving targets)
SN.TerrainName = "WiseTerrainCalibrated"
SN.wiseTerrain.gui = "opencv"			#type of GUI (current version only supports "opencv")
SN.wiseTerrain.gui_wait_start = true 	#press-key to start simulation
SN.wiseTerrain.gui_show = true		  	#shows a cenital view of the network & moving targets
SN.wiseTerrain.draw_trajectory = false  #shows trajectories of moving targets
SN.wiseTerrain.scale_factor = 0.003		#factor to increase (>1) or decrease (<1) the GUI size (ground-plane image)
 
SN.wiseTerrain.GPmap_path =  "../../../videos/Crowd_PETS09/S2/L1/PETS2009_map.png" #path for ground-plane image

# ==============================================
# Communication: Wireless Channel
# ==============================================
SN.dummy_communication = true 			#'false'=enable the wireless communication pipeline 
SN.dummyChannel.collectTraceInfo = true	#enable trace log information in "wise-trace.txt"

### Ideal wireless channel (unit disk model)
SN.wirelessChannel.sigma = 0
SN.wirelessChannel.bidirectionalSigma = 0
SN.wirelessChannel.PLd0 = -172

# ==============================================
# Physical Process (environment's events) 
# ==============================================
SN.numPhysicalProcesses = 7					#number of sensed data (i.e. video files captured by each node)
SN.physicalProcessName = "WiseVideoFile"
SN.physicalProcess[**].frame_rate = -1 		#if frame_rate = -1, the source frame_rate is employed
SN.physicalProcess[**].resize = -1			#if resize = -1, the source resolution is employed
SN.physicalProcess[**].show_video = false	#flag to show input video

SN.physicalProcess[0].file_name = "../../../videos/Crowd_PETS09/S2/L1/view001_7fps_mpeg4.avi"
SN.physicalProcess[1].file_name = "../../../videos/Crowd_PETS09/S2/L1/view003_7fps_mpeg4.avi"
SN.physicalProcess[2].file_name = "../../../videos/Crowd_PETS09/S2/L1/view004_7fps_mpeg4.avi"
SN.physicalProcess[3].file_name = "../../../videos/Crowd_PETS09/S2/L1/view005_7fps_mpeg4.avi"
SN.physicalProcess[4].file_name = "../../../videos/Crowd_PETS09/S2/L1/view006_7fps_mpeg4.avi"
SN.physicalProcess[5].file_name = "../../../videos/Crowd_PETS09/S2/L1/view007_7fps_mpeg4.avi"
SN.physicalProcess[6].file_name = "../../../videos/Crowd_PETS09/S2/L1/view008_7fps_mpeg4.avi"

# ==============================================
# Node: Application 
# ==============================================
SN.node[**].ApplicationName = "WiseCameraCAWCTracker"
SN.node[**].Application.resize = 1					 #resizing factor of input frames employed by the application
SN.node[**].Application.tracker_selected = 0 		 #STRUCK #employed tracker
SN.node[**].Application.show_results = true			 #flag to show the results of each camera (i.e. tracking)
SN.node[**].Application.neighbourDiscoverCOM = false #discovery of network cameras using communications	
SN.node[**].Application.neighbourDiscoverFOV = false #discovery of network cameras using FOV spatial overlap
SN.node[**].Application.collectTraceInfo = true		 #enable trace log information in "wise-trace.txt"
SN.node[**].Application.neighbourFullConnectivity = true #camera nodes are fully connected (i.e. wired network)

#SN.node[**].Application.sensing_mode = "REAL_PERIOD" #frames captured each 'sampling_time', considers processing time
#SN.node[**].Application.sensing_mode = "REAL_DEMAND" #frames captured after processing, considers processing time
SN.node[**].Application.sensing_mode = "IDEAL"#frames captured each 'sampling_time', does not consider processing time

#unique ID for each camera
SN.node[0].Application.camID = 1
SN.node[1].Application.camID = 3
SN.node[2].Application.camID = 4
SN.node[3].Application.camID = 5
SN.node[4].Application.camID = 6
SN.node[5].Application.camID = 7
SN.node[6].Application.camID = 8

#groundtruth initialization for the selected target (uncomment the selected groundtruth)
SN.node[**].Application.initFile_ip_gt = "../../../videos/Crowd_PETS09/S2/L1/Groundtruth/annotations_person_9_ip_init.txt"
#SN.node[**].Application.initFile_ip_gt = "../../../videos/Crowd_PETS09/S2/L1/Groundtruth/annotations_person_11_ip_init.txt"
#SN.node[**].Application.initFile_ip_gt = "../../../videos/Crowd_PETS09/S2/L1/Groundtruth/annotations_person_16_ip_init.txt"  
#SN.node[**].Application.initFile_ip_gt = "../../../videos/Crowd_PETS09/S2/L1/Groundtruth/annotations_person_17_ip_init.txt"

#configuration for utility estimation (mean and variance). These values are obtained with training data (i.e. utility scores)
SN.node[0].Application.score_m = 1
SN.node[0].Application.score_v = 0.75
SN.node[1].Application.score_m = 2
SN.node[1].Application.score_v = 0.75
SN.node[2].Application.score_m = 2
SN.node[2].Application.score_v = 1
SN.node[3].Application.score_m = 2
SN.node[3].Application.score_v = 1
SN.node[4].Application.score_m = 2
SN.node[4].Application.score_v = 0.75
SN.node[5].Application.score_m = 1
SN.node[5].Application.score_v = 1
SN.node[5].Application.score_th = 0.5
SN.node[6].Application.score_m = 2
SN.node[6].Application.score_v = 0.75
SN.node[6].Application.score_th = 0.3

# ==============================================
# Node: Sensor Manager
# ==============================================
SN.node[**].SensorManagerName = "WiseCameraManager"	#type of sensor
SN.node[**].SensorManager.fov_type = "directional"	#for completeness, we indicate that the camera has a directional FOV
SN.node[**].SensorManager.type_src = "Video"		#the source is a video file
SN.node[**].SensorManager.calib_type = "tsai"		#calibration type tsai (http://homepages.inf.ed.ac.uk/rbf/CVonline/LOCAL_COPIES/DIAS1/)
SN.node[0].SensorManager.calib_filename = "../../../videos/Crowd_PETS09/S2/L1/view001_calib.xml" #calibration file for camera 001
SN.node[1].SensorManager.calib_filename = "../../../videos/Crowd_PETS09/S2/L1/view003_calib.xml" #calibration file for camera 003
SN.node[2].SensorManager.calib_filename = "../../../videos/Crowd_PETS09/S2/L1/view004_calib.xml" #calibration file for camera 004
SN.node[3].SensorManager.calib_filename = "../../../videos/Crowd_PETS09/S2/L1/view005_calib.xml" #calibration file for camera 005
SN.node[4].SensorManager.calib_filename = "../../../videos/Crowd_PETS09/S2/L1/view006_calib.xml" #calibration file for camera 006
SN.node[5].SensorManager.calib_filename = "../../../videos/Crowd_PETS09/S2/L1/view007_calib.xml" #calibration file for camera 007
SN.node[6].SensorManager.calib_filename = "../../../videos/Crowd_PETS09/S2/L1/view008_calib.xml" #calibration file for camera 008

# ==============================================
# Node: Resource Managers (cpu, memory, energy)
# ==============================================
SN.node[**].ResourceManager.sigmaCPUClockDrift = 0.0 # Note: 'sigmaCPUClockDrift = 0' means NO drift (ideal)
SN.node[**].ResourceManager.CPUmodel = "../../../models/CPU/CPU_ARM-Cortex-A9.dat" 	#filename of the hardware model for processing    
SN.node[**].ResourceManager.SENmodel = "../../../models/SEN/SEN_B3.dat"				#filename of the hardware model for sensing
SN.node[**].ResourceManager.COMmodel = "../../../models/COM/CC2420.txt"				#filename of the hardware model for communication
SN.node[**].ResourceManager.initialEnergy = 1000									#initial battery energy
SN.node[**].ResourceManager.SENfreq = 24e6											#Frequency for sensing module
SN.node[**].ResourceManager.optimizationFactor = 2 #speedup factor due to optimized code implementation (i.e. faster processing)
 
# ==============================================
# Node: Communication: Radio (Physical Layer)
# ==============================================
### Ideal radio parameters... 
SN.node[**].Communication.Radio.RadioParametersFile = "../../../models/COM/CC2420.txt" #filename of the hardware model for communication
SN.node[**].Communication.Radio.mode = "IDEAL"
SN.node[**].Communication.Radio.collisionModel = 0  # 0:None  1:Simplistic  2:Additive
SN.node[**].Communication.Radio.maxPhyFrameSize = 0 # no limits
SN.node[**].Communication.Radio.phyFrameOverhead = 0 
 
# ==============================================
# Node: Communication: MAC (Datalink Layer)
# ==============================================
### MAC without overhaead (ideal)
SN.node[**].Communication.MAC.macPacketOverhead = 0
SN.node[**].Communication.MACProtocolName = "TMAC"
SN.node[**].Communication.MAC.maxTxRetries = 10
SN.node[**].Communication.MAC.allowSinkSync = false

# ==============================================
# Node: Communication: Routing (Network Layer)
# ==============================================
### Routing without overhaead (ideal)
SN.node[**].Communication.Routing.netDataFrameOverhead = 0
SN.node[**].Communication.**.collectTraceInfo = true

# ==================================================
# SPECIFIC TESTS (extending options under [General])
# ==================================================
#basic functionality
[Config test]
repeat = 1
sim-time-limit = 25s
SN.node[**].Application.testName = "CAWCtest"
SN.node[**].Application.sensing_mode = "IDEAL"
SN.node[**].Application.show_results = true
SN.node[**].ResourceManager.CPUfreq = 1.5e9
SN.node[**].Application.sampling_time = 1/7

#basic functionality without displaying results
[Config test_no_display]
repeat = 1
sim-time-limit = 25s
SN.node[**].Application.testName = "CAWCtest_nodisp"
SN.node[**].Application.sensing_mode = "IDEAL"
SN.node[**].Application.show_results = false
SN.node[**].ResourceManager.CPUfreq = 1.5e9
SN.node[**].Application.sampling_time = 1/7

#tests for a range of operating frequencies for processing and sampling times for sensing
[Config scalable]
repeat = 50
sim-time-limit = 25s
SN.node[**].Application.testName = "CAWCsenVSpro"
SN.node[**].Application.sensing_mode = "REAL_PERIOD" #sensing is independent of processing (so there may be delays if processing is slower than sensing)
SN.node[**].Application.sampling_time = ${sr=1/1,1/2,1/3,1/4,1/5,1/6,1/7}
SN.node[**].ResourceManager.CPUfreq = ${fcpu=2.5e8,5e8,7.5e8,1e9,1.25e9,1.5e9}

#tests for a range of sampling times for sensing
[Config sensing]
repeat = 20
sim-time-limit = 20s
SN.node[**].Application.testName = "CAWCsen"
SN.node[**].Application.sensing_mode = "REAL_PERIOD" #sensing is independent of processing (so there may be delays if processing is slower than sensing)
SN.node[**].Application.sampling_time = ${sr=1/1,1/2.5,1/3,1/4.2,1/5,1/6,1/7}
SN.node[**].ResourceManager.CPUfreq = 1.5e9

#tests for a range of operating frequencies for processing 
[Config processing]
repeat = 50
sim-time-limit = 25s
SN.node[**].Application.testName = "CAWCpro"
SN.node[**].Application.sensing_mode = "REAL_PERIOD" #sensing is independent of processing (so there may be delays if processing is slower than sensing)
SN.node[**].Application.sampling_time = 1/7
SN.node[**].ResourceManager.CPUfreq = ${fcpu=2.5e8, 5e8, 7.5e8, 1e9, 1.25e9, 1.5e9}
SN.node[**].ResourceManager.optimizationFactor = 2

#test for a fixed operating frequency for processing and sampling time for sensing
[Config fixed]
repeat = 50
sim-time-limit = 25s
SN.node[**].Application.testName = "CAWCfixed"
SN.node[**].Application.sensing_mode = "REAL_PERIOD" #sensing is independent of processing (so there may be delays if processing is slower than sensing)
SN.node[**].Application.sampling_time = 1/7
SN.node[**].ResourceManager.CPUfreq = 1.5e9
SN.node[**].ResourceManager.optimizationFactor = 2

#test for a number of code optimization factors
[Config lifetime]
repeat = 50
sim-time-limit = 25s
SN.node[**].Application.testName = "CAWClifetime"
SN.node[**].Application.sensing_mode = "REAL_PERIOD" #sensing is independent of processing (so there may be delays if processing is slower than sensing)
SN.node[**].Application.sampling_time = 1/7
SN.node[**].ResourceManager.CPUfreq = 1.5e9
SN.node[**].ResourceManager.optimizationFactor = ${o=0.25,0.5,2,4,8,16,24}